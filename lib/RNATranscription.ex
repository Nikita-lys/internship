defmodule RNATranscription do
  # use ExUnit.Assertions
  @moduledoc """
  Получив цепочку ДНК, верните ее РНК-комплемент (согласно транскрипции РНК). Обе цепи ДНК и РНК представляют
  собой последовательность нуклеотидов. Четыре нуклеотида, обнаруженные в ДНК, представляют собой аденин (A),
  цитозин (C), гуанин (G) и тимин (T). Четыре нуклеотида, обнаруженные в РНК, представляют собой аденин (А),
  цитозин (С), гуанин (G) и урацил (U).

  Учитывая цепь ДНК, ее транскрибируемая цепь РНК формируется путем замены каждого нуклеотида его комплементом:
  G -> C
  C -> G
  T -> A
  A -> U
  Примеры вызовов, чтобы себя проверить:
  RNATranscription.to_rna('G') вернет 'C'
  RNATranscription.to_rna('T') вернет 'A'
  RNATranscription.to_rna('ACGTGGTCTTAA') вернет 'UGCACCAGAAUU'
  ...
  """

  @doc """
  Приватная рекурсивная функция.
  Если переданный список пуст, то выдаём результат
  """
  defp rna([], res) do
    res
  end

  @doc """
  Приватная рекурсивная функция.
  Разделяем charlist на голову и хвост, применяем к голове Map - dna_to_rna, и следом вызываем рекусию
  от хвоста и результирующей
  """
  defp rna([head | tail], res) do
    # проверяем, состоит ли входная строка только из четырех нуклеотидов, обнаруженных в ДНК
    if [head] in ['G', 'C', 'T', 'A'] do
      # Map, где 'нуклеотид ДНК' => 'нуклеотид РНК'
      dna_to_rna = %{'G' => 'C', 'C' => 'G', 'T' => 'A', 'A' => 'U'}
      # Применяем с первому символу списка символов наш Map и запускаем рекурсию от хвоста и результирующей переменной
      dna_to_rna[[head]] ++ rna(tail, res)
    else
      raise ArgumentError, message: "Invalid argument!"
    end
  end

  @doc """
  По цепочке ДНК, возвращает её РНК-комплемент (согласно транскрипции РНК).
  """
  def to_rna(str) do
    rna(str, '')
  end

end


